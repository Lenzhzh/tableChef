export type ValueType = 'table' | 'number' | 'string' | 'any';

export interface TableValue {
  type: 'table';
  data: Record<string, any>[]; // Array of rows
  columns: string[]; // explicit column ordering
}

export interface NumberValue {
  type: 'number';
  value: number;
}

export interface StringValue {
  type: 'string';
  value: string;
}

export type VariableValue = TableValue | NumberValue | StringValue;

export interface Variable {
  id: string;
  name: string;
  value: VariableValue;
  isOutput?: boolean; // If this variable was generated by the recipe
}

export interface OperationArg {
  name: string;
  type: ValueType | 'variable_ref' | 'select' | 'boolean' | 'text';
  label: string;
  options?: string[]; // for select
  defaultValue?: any;
  description?: string;
  accepts?: ValueType[]; // For variable_ref, what types does it accept?
}

// Function signature for the operation execution logic
// It receives the user arguments and the current variable scope
export type OperationRunFn = (
  args: Record<string, any>, 
  context: Record<string, Variable>
) => Variable | Promise<Variable>; // Returns a new variable (or throws)

export interface OperationDefinition {
  id: string;
  name: string;
  description: string;
  category: string; // 'Input', 'Arithmetic', 'Table', 'Logic', etc.
  args: OperationArg[]; // Definition of arguments required
  run: OperationRunFn; // The implementation logic
}

export interface RecipeStep {
  id: string;
  operationId: string;
  // args stores user configuration. 
  // For 'variable_ref', it holds the variable name.
  // For 'number'/'string', it holds the literal value.
  args: Record<string, any>; 
  disabled?: boolean;
  
  // Output configuration
  outputVarName?: string; // If this step produces a new variable
}

export interface ExecutionLog {
   stepId: string;
   status: 'success' | 'error';
   message?: string;
   output?: VariableValue;
   timestamp: number;
}
